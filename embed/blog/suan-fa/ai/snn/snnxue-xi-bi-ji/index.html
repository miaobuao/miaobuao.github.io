<!DOCTYPE html><script type="module" src="/_astro/BlogPostEmbedLayout.astro_astro_type_script_index_0_lang.CBnQuka3.js"></script> <html lang="zh-CN" class="no-scrollbar"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>SNN学习笔记</title><!-- Open Graph / Facebook --><meta property="og:title" content="SNN学习笔记"><meta property="og:type" content="website"><meta property="og:url" content="https://yangqiuyi.com/embed/blog/suan-fa/ai/snn/snnxue-xi-bi-ji/"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.DY52MY3N.js"></script><link rel="stylesheet" href="/_astro/_slug_.DyZWVpeX.css"><script type="module" src="/_astro/page.nXIIYMne.js"></script></head> <body class="dark:text-white max-w-prose mx-auto">  <div class="flex flex-col rounded-lg"> <header class="p-4 flex flex-col"> <p class="break-all text-lg md:text-xl font-bold"> SNN学习笔记 </p> <p class="text-sm"> 杨秋逸 · 2023-04-24 </p> </header> <article class="prose max-sm:prose-sm dark:prose-invert text-inherit max-w-full py-4 px-4">  <h1 id="snn-学习笔记"><a href="#snn-学习笔记">SNN 学习笔记</a></h1>
<h2 id="snn-和-ann-的区别-1"><a href="#snn-和-ann-的区别-1">SNN 和 ANN 的区别 <sup></sup></a><a href="#user-content-fn-https://blog.csdn.net/yannan_strath/article/details/105761023" id="user-content-fnref-https://blog.csdn.net/yannan_strath/article/details/105761023" data-footnote-ref="" aria-describedby="footnote-label">1</a></h2>
<h3 id="信息载体-information-carrier"><a href="#信息载体-information-carrier">信息载体 information carrier</a></h3>
<p>ANN 使用的是高精度浮点数而 SNN 使用的是 spikes 或可以理解为 1 和 0,这增加了信息在网络中的稀疏性.这些 spike 在网络中有相同的幅度和 duration.
<img alt="图 1" loading="lazy" decoding="async" fetchpriority="auto" width="771" height="234" src="/_astro/2023-04-24_09_09_26_421.CkfgnZqo_Z2ibHKt.webp" ></p>
<h3 id="神经元模型"><a href="#神经元模型">神经元模型</a></h3>
<p><img alt="图 2" loading="lazy" decoding="async" fetchpriority="auto" width="1093" height="388" src="/_astro/2023-04-24_09_11_20_385.BK3f431x_ZWzBgw.webp" ><br>
<strong>左: 传统神经元 右: spiking neuron</strong></p>
<p>ANN 基本神经元是一个加乘运算器用来整合输入该神经元的值 而后接着一个非线性的激活函数, 这种针对确切数值的运算并不适用于二进制脉冲的处理.</p>
<p><strong>spiking neuron 的示例, PSP 代表 post synaptic potential. :</strong>
<img alt="图 3" loading="lazy" decoding="async" fetchpriority="auto" width="957" height="639" src="/_astro/2023-04-24_09_13_11_126.DF7T2v7e_Z1rnxzB.webp" ></p>
<p>那么 PSP 是什么呢? 简单的解释就是神经元上的膜电压变化.例如图三就是一个神经元接受到 spike 后膜电压 u(t) 随着时间 t 的变化.在生物学中, 这种电脉冲的幅值和时间常数是在特定范围内的, 例如图三中, 膜电压在接受到脉冲输入前会一直保持在 -70mV 的地方, 这个值通常叫做静止值(resting value). 当接受到刺激后, 会产生电压变化的幅值. 在变化结束后, 膜电压会归位回起始的静止值.在实际操作中这种波形要怎样产生呢? 科学家们对生物神经元进行实验分析后, 给出了许多神经元的微分方程模型:</p>
<p>比如 <strong>IF neuron</strong>:
<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>C</mi><mi>m</mi></msub><mfrac><mrow><mi>d</mi><msub><mi>V</mi><mi>m</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">    I(t) = C_m \frac{dV_m(t)}{dt}</annotation></semantics></math></span>
可以看出来式子为电容定律的时间导数,<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>C</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">Q = CV</annotation></semantics></math></span>. 当施加输入电流时,膜电压会随时间增加,直到达到恒定阈值 Vth,此时将出现增量函数尖峰,并且电压会重置为其静止电位,此后模型将继续运行.</p>
<p>除此之外还有 <code>Hodgkin–Huxley</code>, <code>LIF</code>, <code>SRM</code> 等, 但 Neuron model 在 SNN 中的作用主要还是作为脉冲序列的处理单元
<strong>单个 spike 产生的膜电压变化:</strong>
<img alt="图 4" loading="lazy" decoding="async" fetchpriority="auto" width="300" height="224" src="/_astro/2023-04-24_09_18_08_213.PazIeZQD_1YNLGQ.webp" ></p>
<p><strong>单个 spiking neuron 接受多个 spike 输入:</strong>
<img alt="图 5" loading="lazy" decoding="async" fetchpriority="auto" width="862" height="378" src="/_astro/2023-04-24_09_18_55_948.Bpejd3-G_UotWz.webp" ><br>
<img alt="图 6" loading="lazy" decoding="async" fetchpriority="auto" width="528" height="320" src="/_astro/2023-04-24_09_19_02_747.4uHGTJji_ZN7V1X.webp" ></p>
<p>突触后神经元会首先按照接受到的时间整合脉冲, 将他们变为膜电压的变化的叠加. 当膜电压超过预先设置好的阈值(<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϑ</mi></mrow><annotation encoding="application/x-tex">\vartheta</annotation></semantics></math></span>)时,突触后 neuron 被认定为收到了足够的刺激从而发出一个脉冲. 发出脉冲后, 膜电压会被重置并且突触后神经元会在一段时间内无法处理接收到的脉冲, 这段时间称为神经元的 refractory period. 在 refractory period 之后, 膜电压会恢复到静止值从而可以准备下一次脉冲的产生. 这就是脉冲神经元一次完整的 spike generation 过程</p>
<h2 id="snn-的学习方法-2"><a href="#snn-的学习方法-2">SNN 的学习方法 <sup></sup></a><a href="#user-content-fn-https://zhuanlan.zhihu.com/p/35796933" id="user-content-fnref-https://zhuanlan.zhihu.com/p/35796933" data-footnote-ref="" aria-describedby="footnote-label">2</a></h2>
<ul>
<li>梯度下降学习算法: <code>SpikeProp</code>, <code>Slayer</code> 等</li>
<li>突触可塑性学习算法</li>
<li>脉冲序列卷积学习算法</li>
</ul>
<p>尽管 SNN 的各种监督学习算法有差异, 但是目标总体一致:
对于给定的多个输入卖葱序列<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_i(t)</annotation></semantics></math></span>和多个目标脉冲序列<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>d</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_d(t)</annotation></semantics></math></span>, 寻找 SNN 合适的突触权重<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span>, 使神经元的输出脉冲序列<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_o(t)</annotation></semantics></math></span>和对应的目标脉冲序列尽可能接近.</p>
<p>SNN 的监督学习算法的关键是构造合适的突触学习规则:</p>
<ol>
<li>神经信息的编解码方法
神经信息的频率编码、相位编码、Time-to-First-Spike 编码、BSA(Bens Spike Algorithm)编码</li>
<li>神经元模型和网络模拟策略
根据复杂程度将脉冲神经网络分为：
<ol>
<li>具有生物可解释性的生理模型</li>
<li>具有脉冲生成机制的非线性模型</li>
<li>具有固定阈值的线性模型</li>
</ol>
</li>
<li>脉冲序列的相似性度量方法</li>
</ol>
<h3 id="基于梯度下降规则的监督学习算法"><a href="#基于梯度下降规则的监督学习算法">基于梯度下降规则的监督学习算法</a></h3>
<p>SNN 梯度下降学习算法的基本思想就是利用神经元目标输出与实际值之间的误差以及误差的反向传播过程, 得到梯度下降结果作为突触权重调节的参考量.</p>
<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>w</mi><mo>=</mo><mo>−</mo><mi>η</mi><mi mathvariant="normal">∇</mi><mi>E</mi><mo>=</mo><mo>−</mo><mi>η</mi><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>E</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">    \Delta w = - \eta \nabla E = - \eta \frac{\partial E}{\partial w}</annotation></semantics></math></span>
<p>梯度下降监督学习的算法分类</p>
<ol>
<li>
<p>所有的神经元限定仅发送一个脉冲</p>
<p>SpikeProp</p>
<p>为了克服神经元内部状态变量由于脉冲发送而导致的不连续性, 限定网络中所有层神经元只能发送一个脉冲.</p>
</li>
<li>
<p>仅输出层限定只能发送一个脉冲</p>
<p>Multi-SpikeProp</p>
<p>对 SNN 的输入层和隐含层神经元的脉冲发送没有限制. 可对一些复杂的刺激性好进行脉冲序列编码, 单输出的神经元仍然限制只能发送一个脉冲.</p>
</li>
<li>
<p>所有层神经元不限制脉冲发放个数</p>
</li>
<li>
<p>其他梯度下降监督学习算法</p>
<p>Tempotron 学习方法: 脉冲神经元通过对目标输出膜电位和实际的输出膜电位误差最小化, 实现突触权重的优化</p>
</li>
</ol>
<h3 id="基于突触可塑性的监督学习算法"><a href="#基于突触可塑性的监督学习算法">基于突触可塑性的监督学习算法</a></h3>
<p>Hebb 提出突触可塑性的假说: <strong>如果两个神经元同时兴奋, 则他们之间的突触得以增强</strong></p>
<p>当突触后神经元脉冲出现在突触前的神经元脉冲之后, 总是引起长时程的增强; 反之, 总是引起长时程的抑制. 这是一类具有生物可解释性的学习算法.</p>
<p>突触可塑性监督学习算法分类:</p>
<ol>
<li>
<p>监督 Hebbian 学习算法</p>
<p>通过<code>"教师"信号</code>使突触后神经元在目标时间发送脉冲, 教师信号可以表示为脉冲发送时间, 也可以转化为神经元的突触电流形式.</p>
<ul>
<li>
<p>基于脉冲发放时间的 Hebbian 学习算法.</p>
<p>在每个学习周期, 学习过程由三个脉冲决定, 包括两个突触前脉冲和一个突触后脉冲. 第一个突触前脉冲表示输入信号, 第二个突触前脉冲表示突触后神经元的目标脉冲</p>
</li>
<li>
<p>通过注入外部输入电流使神经元发送特定的目标脉冲序列.</p>
<p>I-Learning 算法. 目标和实际输出突触电流的误差计算</p>
</li>
</ul>
</li>
<li>
<p>远程监督学习算法</p>
<p>STDP 和 anti-STDP 两个过程结合 -> 远程监督学习方法(Remote Supervised Method. ReSuMe)</p>
<p>应用 ReSuMe 算法训练 SNN, 突触权重的调整仅依赖于输入输出的脉冲序列和 STDP 机制, 与神经元模型和突触类型无关, 因此这个算法可以用于各种神经元模型. (但仅适用于单层神经网络的学习)</p>
</li>
<li>
<p>其他的 STDP 监督学习算法</p>
<ul>
<li>
<p>BCM(Bienenstock-Cooper-Munro)学习规则 + STDP -> SWAT(Synaptic Weight Association Training)算法</p>
<p>SNN 由输入层, 隐含层和输出层构成, 网络中隐含层神经元作为频率滤波器, 输入和目标输出表示为具有固定频率的脉冲序列. 隐含层突触包含兴奋性和抑制性两类. 输出层包含一个训练神经元和多个输出神经元</p>
</li>
<li>
<p>储备池输出层突触延时的监督学习算法</p>
</li>
</ul>
</li>
</ol>
<h3 id="基于脉冲序列卷积的监督学习算法"><a href="#基于脉冲序列卷积的监督学习算法">基于脉冲序列卷积的监督学习算法</a></h3>
<h4 id="脉冲序列卷积学习算法的基本思想"><a href="#脉冲序列卷积学习算法的基本思想">脉冲序列卷积学习算法的基本思想:</a></h4>
<p>选定特定的核函数<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k(t)</annotation></semantics></math></span>, 应用卷积将脉冲序列唯一地转换为一个连续函数.</p>
<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>S</mi><mo>~</mo></mover><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>k</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>f</mi><mo>=</mo><mn>1</mn></mrow><mi>F</mi></munderover><mi>k</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><msup><mi>t</mi><mi>f</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">    \tilde{S}(t) = S(t) * k(t) = \sum\limits_{f=1}^F k(t - t^f)</annotation></semantics></math></span>
<p>通过对脉冲序列基于核函数的卷积计算, 可以将脉冲序列解释为特定的神经生理信号.</p>
<p>通过对脉冲序列内积的差异构造 SNN 的监督学习算法, 两个脉冲序列的内积:</p>
<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>&#x3C;</mo><msub><mover accent="true"><mi>S</mi><mo>~</mo></mover><mi>i</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mover accent="true"><mi>S</mi><mo>~</mo></mover><mi>j</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>></mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><msub><mover accent="true"><mi>S</mi><mo>~</mo></mover><mi>i</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msub><mover accent="true"><mi>S</mi><mo>~</mo></mover><mi>j</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">    &#x3C;\tilde{S}_i(t), \tilde{S}_j(t)> = \int_0^\infty \tilde{S}_i(t) \tilde{S}_j(t)dt</annotation></semantics></math></span>
<p>几种典型的脉冲序列卷积监督学习算法</p>
<ol>
<li>基于线性代数的方法: 不具备误差 BP 机制, 仅适用于单神经元或单层脉冲神经网络</li>
<li>SPAN(Spike Pattern Association Neuron): 应用 LIF(Leaky Intergrate-and-Fire)神经元模型,主要特点是应用核函数将脉冲序列转换为卷积信号, 通过转化后的输入脉冲序列, 神经元目标和实际输出脉冲序列, 应用 Widrow-Hoff 规则调整突触权重</li>
<li>PSD(Precis-Spike-Driven)算法: 突触权重の调整根据目标输出脉冲和实际输出脉冲的误差来判断, 正误差导致长时程增强, 负的误差导致长时程抑制.</li>
</ol>
<h2 id="入门-3"><a href="#入门-3">入门 <sup></sup></a><a href="#user-content-fn-https://zhuanlan.zhihu.com/p/587646331" id="user-content-fnref-https://zhuanlan.zhihu.com/p/587646331" data-footnote-ref="" aria-describedby="footnote-label">3</a></h2>
<p>从 ANN 的角度来理解 SNN 会方便不少. 大致要理解这几件事:</p>
<ol>
<li>:collision: <a href="#%E8%BE%93%E5%85%A5%E7%BC%96%E7%A0%81">输入编码</a></li>
<li>:collision: <a href="#%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84">模型结构</a></li>
<li>:collision: <a href="#%E8%BE%93%E5%87%BA%E7%BC%96%E7%A0%81">输出编码</a></li>
<li>:collision: <a href="#loss%E5%87%BD%E6%95%B0">loss 函数</a></li>
<li>:collision: <a href="#%E5%8F%82%E6%95%B0%E6%9B%B4%E6%96%B0">参数更新</a></li>
</ol>
<h3 id="输入编码"><a href="#输入编码">输入编码</a></h3>
<p>SNN 中, 输入需要编码为离散的 0/1, 编码方式大致分为 rate coding 和 temporal coding (latency coding)
<img alt="图 1" loading="lazy" decoding="async" fetchpriority="auto" width="720" height="378" src="/_astro/7cfc8c584257e0827119dd33cc184ae13c5789eee3cc7a86ff067c74714e544f._6p_T6VS_1I5tt5.webp" ></p>
<h4 id="rating-coding"><a href="#rating-coding">rating coding</a></h4>
<p>首先我们要对一张图片拓展一个时间维度(num_step), 将图片复制 t 次, 形成一个 tensor; 然后将像素点归一化, 再对每个像素点取伯努利分布确定该点是 0 还是 1</p>
<h4 id="latency-coding"><a href="#latency-coding">latency coding</a></h4>
<p>假设时间步为 256, 根据像素点的数值来确定每个时间步的切片上对应的像素是 0 还是 1</p>
<h4 id="delta-modulation-4"><a href="#delta-modulation-4">Delta Modulation <sup></sup></a><a href="#user-content-fn-https://snntorch.readthedocs.io/en/latest/_modules/snntorch/spikegen.html#delta" id="user-content-fnref-https://snntorch.readthedocs.io/en/latest/_modules/snntorch/spikegen.html#delta" data-footnote-ref="" aria-describedby="footnote-label">4</a></h4>
<p>假设我们有一个视频, 那么我们有两种方式计算 Delta Modulation, 一种是复制第一帧, 插入在最前面, 然后删除最后一帧, 再把原视频减去我们得到的新视频, 得到 X; 第二种方法是在视频的最前面插入一个全 0 矩阵, 再把原视频减去新视频得到 X.</p>
<p>得到 X 之后我们在根据阈值来决定每个像素是 0 还是 1.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="py"><code><span class="line"><span style="color:#E1E4E8">a </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> torch.Tensor</span><span style="color:#79b8ff">(</span><span style="color:#ffab70">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2.9</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3.9</span><span style="color:#ffab70">]</span><span style="color:#79b8ff">)</span></span>
<span class="line"><span style="color:#E1E4E8">spikegen.delta</span><span style="color:#79b8ff">(</span><span style="color:#E1E4E8">a, </span><span style="color:#FFAB70">threshold</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#79b8ff">)</span></span>
<span class="line"><span style="color:#F97583">></span><span style="color:#F97583">></span><span style="color:#F97583">></span><span style="color:#E1E4E8"> tensor</span><span style="color:#79b8ff">(</span><span style="color:#ffab70">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">., </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">., </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">., </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">., </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">.</span><span style="color:#ffab70">]</span><span style="color:#79b8ff">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">spikegen.delta</span><span style="color:#79b8ff">(</span><span style="color:#E1E4E8">a, </span><span style="color:#FFAB70">threshold</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">padding</span><span style="color:#F97583">=</span><span style="color:#79B8FF">True</span><span style="color:#79b8ff">)</span></span>
<span class="line"><span style="color:#F97583">></span><span style="color:#F97583">></span><span style="color:#F97583">></span><span style="color:#E1E4E8"> tensor</span><span style="color:#79b8ff">(</span><span style="color:#ffab70">[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">., </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">., </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">., </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">., </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">.</span><span style="color:#ffab70">]</span><span style="color:#79b8ff">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">b </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> torch.Tensor</span><span style="color:#79b8ff">(</span><span style="color:#ffab70">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2.9</span><span style="color:#ffab70">]</span><span style="color:#79b8ff">)</span></span>
<span class="line"><span style="color:#E1E4E8">spikegen.delta</span><span style="color:#79b8ff">(</span><span style="color:#E1E4E8">b, </span><span style="color:#FFAB70">threshold</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">off_spike</span><span style="color:#F97583">=</span><span style="color:#79B8FF">True</span><span style="color:#79b8ff">)</span></span>
<span class="line"><span style="color:#F97583">></span><span style="color:#F97583">></span><span style="color:#F97583">></span><span style="color:#E1E4E8"> tensor</span><span style="color:#79b8ff">(</span><span style="color:#ffab70">[</span><span style="color:#E1E4E8"> </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">.,  </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">., </span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">.,  </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">.,  </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">.</span><span style="color:#ffab70">]</span><span style="color:#79b8ff">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">spikegen.delta</span><span style="color:#79b8ff">(</span><span style="color:#E1E4E8">b, </span><span style="color:#FFAB70">threshold</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">padding</span><span style="color:#F97583">=</span><span style="color:#79B8FF">True</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">off_spike</span><span style="color:#F97583">=</span><span style="color:#79B8FF">True</span><span style="color:#79b8ff">)</span></span>
<span class="line"><span style="color:#F97583">></span><span style="color:#F97583">></span><span style="color:#F97583">></span><span style="color:#E1E4E8"> tensor</span><span style="color:#79b8ff">(</span><span style="color:#ffab70">[</span><span style="color:#E1E4E8"> </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">.,  </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">., </span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">.,  </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">.,  </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">.</span><span style="color:#ffab70">]</span><span style="color:#79b8ff">)</span></span></code></pre>
<h3 id="模型结构"><a href="#模型结构">模型结构</a></h3>
<p><img alt="图 2" loading="lazy" decoding="async" fetchpriority="auto" width="720" height="417" src="/_astro/ee8ff59f3c1d120e3d455d0c49f3cea05d4a16a96a6de3ff8b643556d4ee5921.BPlXVSuM_13jhpw.webp" ></p>
<p>目前主流模型还是基于 LIF 构建的</p>
<h3 id="输出编码"><a href="#输出编码">输出编码</a></h3>
<p>输出编码可以分为:</p>
<ol>
<li>rate coding</li>
<li>temporal coding</li>
<li>population coing</li>
</ol>
<h4 id="rate-coding"><a href="#rate-coding">rate coding</a></h4>
<p>考虑一个 10 分类任务, output layer 设置 10 个 neuron, 统计一段时间内每个 neuron 发出的脉冲个数, 脉冲数量最多的类作为最终的预测结果.</p>
<h4 id="temporal-coding"><a href="#temporal-coding">temporal coding</a></h4>
<p>同样考虑一个多分类任务, 最先发出脉冲的类作为预测结果</p>
<h4 id="population-coing"><a href="#population-coing">population coing</a></h4>
<p>同样考虑一个 10 分类任务, 设置 500 个 neuron,每个类分配 50 个 neuron, 统计短时间内每个类对应的 neuron 的脉冲个数, 最多的作为预测结果.</p>
<h3 id="loss-函数"><a href="#loss-函数">loss 函数</a></h3>
<p>损失函数居然和 ANN 是一样的</p>
<h3 id="参数更新"><a href="#参数更新">参数更新</a></h3>
<p>SNN 可以看成一种 RNN, 所以 RNN 的方法都能适用于 SNN. RNN 有两类参数更新的方法:</p>
<ol>
<li><strong>spatial credit assignment</strong>: backpropagation</li>
<li><strong>temporal credit assignment</strong>:
<ul>
<li>backward method: backpropagation trough time</li>
<li>forward method: <a href="https://arxiv.org/abs/1901.09948">Surrogate Gradient Learning in Spiking Neural Networks</a> Page 7 最下面</li>
</ul>
</li>
</ol>
<h4 id="snn-梯度更新"><a href="#snn-梯度更新">SNN 梯度更新</a></h4>
<ul>
<li>local learning</li>
<li>network translation</li>
<li>smooth neural network</li>
<li>surrogate gradient</li>
</ul>
<section data-footnotes="" class="footnotes"><h2 class="sr-only" id="footnote-label"><a href="#footnote-label">Footnotes</a></h2>
<ol>
<li id="user-content-fn-https://blog.csdn.net/yannan_strath/article/details/105761023">
<p><a href="https://blog.csdn.net/Yannan_Strath/article/details/105761023">https://blog.csdn.net/Yannan_Strath/article/details/105761023</a> <a href="#user-content-fnref-https://blog.csdn.net/yannan_strath/article/details/105761023" data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-https://zhuanlan.zhihu.com/p/35796933">
<p><a href="https://zhuanlan.zhihu.com/p/35796933">https://zhuanlan.zhihu.com/p/35796933</a> <a href="#user-content-fnref-https://zhuanlan.zhihu.com/p/35796933" data-footnote-backref="" aria-label="Back to reference 2" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-https://zhuanlan.zhihu.com/p/587646331">
<p><a href="https://zhuanlan.zhihu.com/p/587646331">https://zhuanlan.zhihu.com/p/587646331</a> <a href="#user-content-fnref-https://zhuanlan.zhihu.com/p/587646331" data-footnote-backref="" aria-label="Back to reference 3" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-https://snntorch.readthedocs.io/en/latest/_modules/snntorch/spikegen.html#delta">
<p><a href="https://snntorch.readthedocs.io/en/latest/_modules/snntorch/spikegen.html#delta">https://snntorch.readthedocs.io/en/latest/_modules/snntorch/spikegen.html#delta</a> <a href="#user-content-fnref-https://snntorch.readthedocs.io/en/latest/_modules/snntorch/spikegen.html#delta" data-footnote-backref="" aria-label="Back to reference 4" class="data-footnote-backref">↩</a></p>
</li>
</ol>
</section>  </article> </div> <div class="mt-8 p-2"> <script type="module" src="/_astro/Giscus.astro_astro_type_script_index_0_lang.C2pfN53L.js"></script> <giscus-widget repo="miaobuao/miaobuao.github.io" repoId="R_kgDOJONNeg" categoryId="DIC_kwDOJONNes4CVJhu" mapping="og:title" strict="0" reactionsEnabled="1" emitMetadata="0" inputPosition="top" theme="preferred_color_scheme" lang="zh-CN" loading="lazy"></giscus-widget> </div><div class="h-16 sm:h-0"></div>  </body></html>