<!DOCTYPE html><script type="module" src="/_astro/BlogPostLayout.astro_astro_type_script_index_0_lang.CQKIrR8a.js"></script> <html lang="zh-CN" class="no-scrollbar"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>数据结构-期末复习</title><!-- Open Graph / Facebook --><meta property="og:title" content="数据结构-期末复习"><meta property="og:type" content="website"><meta property="og:url" content="https://yangqiuyi.com/blog/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"><meta name="description" content="周志光老师划分的范围 qwq,
本来不紧张的，划完就紧张了...

"><meta property="og:description" content="周志光老师划分的范围 qwq,
本来不紧张的，划完就紧张了...

"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.DY52MY3N.js"></script><link rel="stylesheet" href="/_astro/_slug_.DyZWVpeX.css">
<style>progressive-image[data-astro-cid-njl3qch2]{display:block}
@keyframes astroFadeInOut{0%{opacity:1}to{opacity:0}}@keyframes astroFadeIn{0%{opacity:0;mix-blend-mode:plus-lighter}to{opacity:1;mix-blend-mode:plus-lighter}}@keyframes astroFadeOut{0%{opacity:1;mix-blend-mode:plus-lighter}to{opacity:0;mix-blend-mode:plus-lighter}}@keyframes astroSlideFromRight{0%{transform:translate(100%)}}@keyframes astroSlideFromLeft{0%{transform:translate(-100%)}}@keyframes astroSlideToRight{to{transform:translate(100%)}}@keyframes astroSlideToLeft{to{transform:translate(-100%)}}@media(prefers-reduced-motion){::view-transition-group(*),::view-transition-old(*),::view-transition-new(*){animation:none!important}[data-astro-transition-scope]{animation:none!important}}
</style><script type="module" src="/_astro/page.nXIIYMne.js"></script><style>[data-astro-transition-scope="astro-uniujczg-1"] { view-transition-name: avatar; }@layer astro { ::view-transition-old(avatar) { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeOut; }::view-transition-new(avatar) { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeIn; }[data-astro-transition=back]::view-transition-old(avatar) { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeOut; }[data-astro-transition=back]::view-transition-new(avatar) { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeIn; } }[data-astro-transition-fallback="old"] [data-astro-transition-scope="astro-uniujczg-1"],
			[data-astro-transition-fallback="old"][data-astro-transition-scope="astro-uniujczg-1"] { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeOut; }[data-astro-transition-fallback="new"] [data-astro-transition-scope="astro-uniujczg-1"],
			[data-astro-transition-fallback="new"][data-astro-transition-scope="astro-uniujczg-1"] { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeIn; }[data-astro-transition=back][data-astro-transition-fallback="old"] [data-astro-transition-scope="astro-uniujczg-1"],
			[data-astro-transition=back][data-astro-transition-fallback="old"][data-astro-transition-scope="astro-uniujczg-1"] { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeOut; }[data-astro-transition=back][data-astro-transition-fallback="new"] [data-astro-transition-scope="astro-uniujczg-1"],
			[data-astro-transition=back][data-astro-transition-fallback="new"][data-astro-transition-scope="astro-uniujczg-1"] { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeIn; }</style></head> <body class="dark:text-white"> <div class="relative h-screen pointer-events-none"> <div class="absolute w-screen h-screen pointer-events-none" data-astro-transition-persist="bg"> <script type="module" src="/_astro/ProgressiveImage.astro_astro_type_script_index_0_lang.Zsl7yvEt.js"></script> <progressive-image data-url="/images/3e171a532cf6845d0fe58924cc998f9b1c7244546777b816d44fe196656b3c4b.webp" data-thumbnailUrl="/images/3e171a532cf6845d0fe58924cc998f9b1c7244546777b816d44fe196656b3c4b_48x.webp" data-image-class="object-cover object-center size-full pointer-events-none" data-astro-cid-njl3qch2="true" class="relative size-full pointer-events-none"> <img src="/images/3e171a532cf6845d0fe58924cc998f9b1c7244546777b816d44fe196656b3c4b_48x.webp" class="image-pixelated object-cover object-center size-full pointer-events-none" data-astro-cid-njl3qch2> </progressive-image>  </div> <div class="pointer-events-auto"><div class="absolute size-full max-w-7xl left-0 right-0 mx-auto sm:p-2"> <div class="sm:glassmorphism size-full rounded-md flex flex-row gap-2"> <div class="fixed w-full sm:w-50 lg:w-52 bottom-0 left-0 z-50 sm:static sm:flex sm:flex-col sm:overflow-auto no-scrollbar gap-2"> <div class="hidden sm:flex flex-col gap-1 justify-center items-center p-4" data-astro-transition-persist="author-info"> <img src="https://avatars.githubusercontent.com/u/62047803?v=4" alt="秋逸" class="rounded-full size-24 select-none" loading="lazy"> <p class="text-2xl font-bold">杨秋逸</p> <p class="text-sm">To Be A Geek :)</p> </div> <div class="flex flex-row sm:flex-col w-full justify-around border-none max-sm:glassmorphism sm:p-2"> <a class="transition-all flex flex-col items-center justify-center py-2 rounded-md max-sm:gap-0.5 sm:flex-row sm:justify-start sm:gap-4 sm:px-4 border-none  sm:glassmorphism" role="button" tabindex="0" href="/"> <div class="flex justify-center items-center"> <i class="icon-[material-symbols--nest-clock-farsight-analog] size-6 sm:size-8"></i> </div> <div class="text-xs sm:text-base select-none">  
Timeline
 </div> </a> <a class="transition-all flex flex-col items-center justify-center py-2 rounded-md max-sm:gap-0.5 sm:flex-row sm:justify-start sm:gap-4 sm:px-4 border-none" role="button" tabindex="0" href="/archive"> <div class="flex justify-center items-center"> <i class="icon-[icon-park-outline--calendar] size-6 sm:size-8"></i> </div> <div class="text-xs sm:text-base select-none">  
Archive
 </div> </a>   <a class="transition-all flex flex-col items-center justify-center py-2 rounded-md max-sm:gap-0.5 sm:flex-row sm:justify-start sm:gap-4 sm:px-4 border-none hidden sm:flex" role="button" tabindex="0" href="/friend-links/"> <div class="flex justify-center items-center"> <i class="icon-[icon-park-outline--friends-circle] size-6 sm:size-8"></i> </div> <div class="text-xs sm:text-base select-none">  
Friends
 </div> </a> <a class="transition-all flex flex-col items-center justify-center py-2 rounded-md max-sm:gap-0.5 sm:flex-row sm:justify-start sm:gap-4 sm:px-4 border-none max-sm:flex hidden" role="button" tabindex="0" href="/finder"> <div class="flex justify-center items-center"> <i class="icon-[ix--navigation] size-6 sm:size-8"></i> </div> <div class="text-xs sm:text-base select-none">  
Finder
 </div> </a> <a class="transition-all flex flex-col items-center justify-center py-2 rounded-md max-sm:gap-0.5 sm:flex-row sm:justify-start sm:gap-4 sm:px-4 border-none" role="button" tabindex="0" href="/about-me"> <div class="flex justify-center items-center"> <i class="icon-[material-symbols--sentiment-excited-outline] size-6 sm:size-8"></i> </div> <div class="text-xs sm:text-base select-none">  
About Me
 </div> </a> </div> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="Z2plROE" component-url="/_astro/WindowsList.De5TXCyW.js" component-export="WindowsList" renderer-url="/_astro/client.DkS6DsO7.js" props="{&quot;className&quot;:[0,&quot;flex-1 hidden sm:flex flex-col gap-1 overflow-auto px-2&quot;]}" ssr client="only" opts="{&quot;name&quot;:&quot;WindowsList&quot;,&quot;value&quot;:&quot;solid-js&quot;}"></astro-island> </div> <main id="main-scroll-container" class="overflow-auto h-full flex-1 no-scrollbar"> <div class="p-2 sm:pl-0">  <div class="flex flex-col glassmorphism rounded-lg"> <header class="p-4 gap-3 flex items-center sm:hidden"> <img src="https://avatars.githubusercontent.com/u/62047803?v=4" alt="秋逸" class="size-[3rem] rounded-full select-none" data-astro-transition-scope="astro-uniujczg-1"> <div class="flex flex-col"> <p class="break-all text-lg md:text-xl font-bold"> 数据结构-期末复习 </p> <p class="text-sm"> 杨秋逸 · 2021-07-01 </p> </div> </header> <article class="prose max-sm:prose-sm dark:prose-invert text-inherit max-w-full py-4 px-4 md:px-8">  <p>周志光老师划分的范围 qwq,
本来不紧张的，划完就紧张了…</p>
<!--more-->
<h2 id="线性表-顺序存储"><a href="#线性表-顺序存储">线性表-顺序存储</a></h2>
<blockquote>
<p>零个或多个数据元素的有限序列</p>
</blockquote>
<h3 id="特征"><a href="#特征">特征</a></h3>
<p>1．集合元素是有限个
2．除最后一个元素之外，均有唯一的后继(后件)。
3．除第一个元素之外，均有唯一的前驱(前件)。</p>
<h3 id="基本操作"><a href="#基本操作">基本操作</a></h3>
<p>InitList(*L) 初始化操作，建立一个空的线性表
IsListEmpty(L) 判断线性表是否为空，若为空，返回 true，否则 false
ClearList(*L) 清空线性表
GetElem(L, i, *e) 将线性表 L 中的第 i 个位置的元素返回给 e
LocateElem(L, e) 在线性表 L 中查找与给定值 e 相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回 0 表示失败。
ListInsert(*L, i, e) 在线性表 L 中的第 i 个位置插入新元素 e
ListDelete(*L, i, *e) 删除线性表 L 中第 i 个位置元素，并用 e 返回其值
ListLength(L) 返回线性表 L 的长度，即元素个数.</p>
<h3 id="结构体定义"><a href="#结构体定义">结构体定义</a></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> ElemType;</span></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">	ElemType data</span><span style="color:#ffab70">[</span><span style="color:#E1E4E8">MAXSIZE</span><span style="color:#ffab70">]</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> length;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">SqList</span><span style="color:#E1E4E8">;</span></span></code></pre>
<p>数组 data 的存储位置
线性表的最大存储容量
线性表的当前长度</p>
<h3 id="优缺点"><a href="#优缺点">优缺点</a></h3>
<p><strong>优点：</strong>
无须为表示表中元素的逻辑关系而额外增加存储空间；
可以快速地存取任一位置的元素。</p>
<p><strong>缺点：</strong>
插入和删除需要移动大量元素；
当线性表长度变化较大时，难以确定存储空间的容量；
造成存储空间的碎片。</p>
<h2 id="线性表-链式存储"><a href="#线性表-链式存储">线性表-链式存储</a></h2>
<blockquote>
<p>为了表示每个数据元素 ai 与其直接后继元素 ai+1 之间的逻辑关系，对于数据元素 ai 来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继 ai+1 的存储位置）。我们把存储数据元素信息的空间称为数据域；把存储后继位置的空间称为指针域。指针域中存储的信息称为指针或链。这两部分信息组成数据元素的存储映像，称为结点（Node）。</p>
</blockquote>
<h3 id="头指针和头节点"><a href="#头指针和头节点">头指针和头节点</a></h3>
<p><strong>头指针：</strong>
链表中第一个结点的存储位置叫做头指针</p>
<p>头指针是指向链表第一个结点的指针，若链表有头结点，则是指向头结点的指针；
头指针具有标识作用，所以常用头指针冠以链表的名字；
无论链表是否为空，头指针不为空，头指针是链表的必要元素。</p>
<p><strong>头结点：</strong>
为了更方便对链表的操作，会在单链表的第一个结点之前增加一个结点，称为头结点。</p>
<p>头结点是为了操作的统一和方便而设立的，放在第一个元素之前，其数据域一般无意义；
有了头结点，在对第一个结点前插入结点和删除第一个结点，其操作和其他结点的操作就统一了；
头结点不一定是链表的必要元素。</p>
<h3 id="结构体"><a href="#结构体">结构体</a></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> Node</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">	ElemType data;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#B392F0"> Node</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> next;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">Node</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> Node</span><span style="color:#E1E4E8">* LinkList;</span></span></code></pre>
<h2 id="单链表与顺序存储的对比"><a href="#单链表与顺序存储的对比">单链表与顺序存储的对比</a></h2>
<p><strong>存储分配方式：</strong>
顺序存储结构用一段连续的存储空间依次存储线性表的数据元素；
单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素；</p>
<p><strong>时间性能：</strong></p>
<ul>
<li><strong>查找</strong>
顺序存储结构 O(1)
单链表 O(n)</li>
<li><strong>插入和删除</strong>
顺序存储结构需要平均移动表长一半的元素，时间复杂度为 O(n)
单链表在获得某位置的指针后，插入和删除的时间仅为 O(1)</li>
</ul>
<p><strong>空间性能：</strong></p>
<ol>
<li>顺序存储结构需要预分配存储空间，分大了，浪费，分小了，不够用；</li>
<li>单链表不需要分配存储空间，只要内存空间有，就可以分配，元素的个数更是不受限制</li>
</ol>
<h2 id="静态链表"><a href="#静态链表">静态链表</a></h2>
<p><strong>用数组来代替指针：</strong>
数组的每一个下标都对应一个 data 和 cur；
data 中存放数据；
cur 存放该元素的后继元素的下标；
线性表链式存储结构的游标实现法</p>
<h3 id="结构体-1"><a href="#结构体-1">结构体</a></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">	ElemType data;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> cur;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">Component</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">StaticLinkList</span><span style="color:#79b8ff">[</span><span style="color:#B392F0">MAXSIZE</span><span style="color:#79b8ff">]</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h3 id="细节"><a href="#细节">细节</a></h3>
<p>第一个元素的 cur 存放备用链表第一个结点的下标；
最后一个元素的 cur 存放当前链表第一个有数值元素的下标；</p>
<h2 id="循环链表"><a href="#循环链表">循环链表</a></h2>
<p>将单链表中终端结点的指针由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相连的单链表称为单循环链表，简称循环链表</p>
<h2 id="双向链表"><a href="#双向链表">双向链表</a></h2>
<p>在单链表的每个结点中，再设置一个指向其前驱结点的指针。</p>
<h3 id="结构体-2"><a href="#结构体-2">结构体</a></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> DulNode</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">	ElemType data;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#B392F0"> DulNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> prior;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#B392F0"> DulNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> next;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">DulNode</span><span style="color:#E1E4E8">,</span><span style="color:#F97583">*</span><span style="color:#B392F0">DulLinkList</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h2 id="线性表-作业"><a href="#线性表-作业">线性表-作业</a></h2>
<p><strong>线性表的基本操作：</strong>
插入，删除，查找，…
线性表的复杂操作
并集，交集，…</p>
<p><strong>PAT 题目集合：</strong>
两个有序链表序列的合并
两个有序链表序列的交集
一元多项式的乘法与加法运算
打印选课学生名单
一元多项式求导
Reversing Linked List</p>
<h2 id="栈"><a href="#栈">栈</a></h2>
<p>栈（Stack）是限定仅在表尾进行插入和删除操作的<strong>线性表</strong>。</p>
<ul>
<li>栈是线性表，即栈的元素具有线性关系，即前驱后继关系</li>
<li>线性表可以在表中任何位置进行插入、删除操作</li>
<li>栈只能在表尾进行插入、删除操作</li>
<li>表尾称为栈顶</li>
</ul>
<p><strong>插入操作：</strong>
进栈、压栈、入栈</p>
<p><strong>删除操作：</strong>
出栈、弹栈</p>
<p><strong>应用：</strong></p>
<p>递归
四则运算表达式求值</p>
<h3 id="顺序栈"><a href="#顺序栈">顺序栈</a></h3>
<p>同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系。</p>
<h4 id="结构体-3"><a href="#结构体-3">结构体</a></h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">	ElemType data</span><span style="color:#ffab70">[</span><span style="color:#E1E4E8">MAXSIZE</span><span style="color:#ffab70">]</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> top;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">SqStack</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h4 id="优缺点-1"><a href="#优缺点-1">优缺点</a></h4>
<p><strong>优点：</strong>
后进先出规则的实现；
插入、删除尤其方便；</p>
<p><strong>缺点：</strong>
栈的大小是固定的；</p>
<h3 id="链栈"><a href="#链栈">链栈</a></h3>
<h4 id="结构体-4"><a href="#结构体-4">结构体</a></h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> StackNode</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">	ElemType data;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#B392F0"> StackNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> next;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">StackNode</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">*</span><span style="color:#B392F0">LinkStackPtr</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> LinkStack</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">	LinkStackPtr top;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> count;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">LinkStack</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h3 id="基本操作-1"><a href="#基本操作-1">基本操作</a></h3>
<p><strong>InitStack ( *S )</strong>：初始化操作.建立一个空栈 S。
<strong>DestroyStack ( *S )</strong>：若栈存在，則销毁它。
<strong>ClearStack (*S)</strong>：将栈清空。
<strong>StackEmpty ( S )</strong><directive-box-若栈为空></directive-box-若栈为空>，返回 true,否則返回 false。
<strong>GetTop (S,*e)</strong>：若栈存在且非空，用 e 返回 S 的栈顶元素。
<strong>Push (*S,e)</strong>：若栈 S 存在，插入新元素 e 到栈 S 中并成为栈頂元素。
<strong>Pop (*S,*e)</strong>：删除栈 S 中栈顶元素，并用 e 返回其值。
<strong>StackLength (S)</strong>：返回回栈 S 的元素个数。</p>
<h2 id="队列"><a href="#队列">队列</a></h2>
<p>队列（Queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
<p>队列是一种先进先出（First In First Out）的线性表，简称 FIFO。
允许插入的一端称为<strong>队尾</strong>；
允许删除的一端称为<strong>队头</strong>。</p>
<h3 id="基本操作-2"><a href="#基本操作-2">基本操作</a></h3>
<p><strong>InitQueue(*Q)</strong>：初始化操作，建立一个空队列 Q；
<strong>DestroyQueue(*Q)</strong>：若队列 Q 存在，則销毀它；
<strong>ClearQueue(*Q)</strong>：将队列 Q 清空；
<strong>QueueEmpty(Q)</strong>：若队列 Q 为空，则 true，否則 false；
<strong>GetHead(Q, *e)</strong>：若队列 Q 存在且非空，用 e 返因队列 Q 的队头元素；
<strong>EnQueue(*Q,e)</strong>：若队列 Q 存在，插入新元素 e 到队列 Q 中并成为队尾元素；
<strong>DeQueue(*Q, *e)</strong>：刪除队列 Q 中队头，并用 e 返回其值；
<strong>QueueLength(Q)</strong>：送回队列 Q 的元素个数。</p>
<h3 id="缺点"><a href="#缺点">缺点</a></h3>
<ol>
<li>
<p>出队的时候，队列中所有元素都要向前移动一个位置，复杂度为 O(n)；</p>
</li>
<li>
<p>队列的大小是固定的；</p>
</li>
</ol>
<h3 id="循环队列"><a href="#循环队列">循环队列</a></h3>
<p>循环队列解决<strong>假溢出问题</strong></p>
<h4 id="结构体-5"><a href="#结构体-5">结构体</a></h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">	ElymType data</span><span style="color:#ffab70">[</span><span style="color:#E1E4E8">MAXSIZE</span><span style="color:#ffab70">]</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> front;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> rear;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">SqQueque</span><span style="color:#E1E4E8">;</span></span></code></pre>
<p>头尾相接的顺序存储结构—循环队列
rear==front 时，队空
rear+1== front，队满</p>
<p><strong>队空判断</strong>：
rear==front
<strong>队满判断：</strong>
（rear+1）%QueueSize==front
<strong>队长判断：</strong>
(rear-front+QueueSize)%QueueSize</p>
<h3 id="链式队列"><a href="#链式队列">链式队列</a></h3>
<p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它称为链队列。</p>
<h4 id="结构体-6"><a href="#结构体-6">结构体</a></h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> QNode</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">	ElymType data;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#B392F0"> QNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> next;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">QNode</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">*</span><span style="color:#B392F0">QueuePtr</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">	QueuePtr front;</span></span>
<span class="line"><span style="color:#E1E4E8">	QueuePtr rear;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">LinkQueue</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h2 id="栈与队列-作业"><a href="#栈与队列-作业">栈与队列 作业</a></h2>
<p><strong>栈：</strong>
顺序栈基本操作
链栈基本操作
四则混合运算（基于栈的实现）</p>
<p><strong>队列：</strong>
顺序队列基本操作
链队列基本操作
迷宫问题</p>
<h2 id="串"><a href="#串">串</a></h2>
<p>串（string）是由零个或多个字符组成的有限序列，又名字符串。</p>
<p>串中的元素仅由一个字符组成，相邻元素具有前驱和后继关系.</p>
<h3 id="顺序存储"><a href="#顺序存储">顺序存储</a></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> mystring</span><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#F97583">    char</span><span style="color:#E1E4E8"> str</span><span style="color:#ffab70">[</span><span style="color:#E1E4E8">MaxStrSize</span><span style="color:#ffab70">]</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> length;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">MyString</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h3 id="链式存储"><a href="#链式存储">链式存储</a></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> node</span><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#F97583">    char</span><span style="color:#E1E4E8"> data;</span></span>
<span class="line"><span style="color:#F97583">    struct</span><span style="color:#B392F0"> node</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">next;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">LinkStrNode</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#E1E4E8"> LinkStrNode </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> LinkString;</span></span></code></pre>
<h3 id="基本操作-3"><a href="#基本操作-3">基本操作</a></h3>
<p><strong>StrAssign (&#x26;T, chars)</strong>：初始条件 chars 是字符串常量；操作结果生成一个其值等于 chars 的串 T；
<strong>StrCopy (&#x26;T, S)</strong>：初始条件串 S 存在；操作结果由串 S 复制得串 T；
<strong>StrEmpty(S)</strong>：初始条件串 S 存在；操作结果若 S 为空串，则返回 TRUE，否则返回 FALSE；
<strong>StrCompare(S, T)</strong>：初始条件串 S 和 T 存在；操作结果若 S>T，则返回值>0；若 S=T，则返回值＝ 0；若 S &#x3C; T，则返回值 &#x3C; 0；
<strong>StrLength(S)</strong>：初始条件串 S 存在；操作结果返回 S 的元素个数，称为串的长度。</p>
<h2 id="树"><a href="#树">树</a></h2>
<p>树（Tree）是 n 个结点的有限集合，n=0 是空树。在任意一棵非空树中：</p>
<h3 id="特征-1"><a href="#特征-1">特征</a></h3>
<ul>
<li>有且仅有一个特定的称为根的结点；</li>
<li>其余结点可分为 m 个互不相交的有限集；</li>
<li>每个有限集本身又是一棵树，并且称为根的子树。</li>
</ul>
<h3 id="概念"><a href="#概念">概念</a></h3>
<p><strong>结点的度：</strong>
结点所拥有子树的数目</p>
<p><strong>叶子结点：</strong>
度为 0 的结点</p>
<p><strong>分支结点或非终端结点：</strong>
根结点
内部结点</p>
<p><strong>树的度：</strong>
树中各个结点的度的最大值</p>
<p><strong>孩子结点：</strong>
结点的子树的根称为孩子结点</p>
<p><strong>双亲结点：</strong>
该结点称为孩子结点的双亲结点</p>
<p><strong>兄弟结点：</strong>
同一个双亲的孩子之间互称兄弟结点</p>
<p><strong>祖先结点：</strong>
从根结点到该结点所经分支上的所有结点</p>
<p><strong>子孙结点：</strong>
以该结点为根的子树中，任意一个结点就是该结点的子孙结点</p>
<p><strong>树的层次：</strong>
树根为第 1 层，根的孩子为第 2 层</p>
<p><strong>树的深度：</strong>
树中结点最大层数为树的深度或高度</p>
<p><strong>有序树：</strong>
各个子树是从左到右，不能互换的</p>
<p><strong>森林：</strong>
m 棵互不相交的树的集合</p>
<h3 id="adt-抽象数据类型"><a href="#adt-抽象数据类型">ADT (抽象数据类型)</a></h3>
<p><strong>Data：</strong>
具有相同数据类型，具有层次关系的数据</p>
<p><strong>Operation：</strong>
<strong>InitTree(&#x26;T)</strong>; //构造空树 T。
<strong>DestroyTree(&#x26;T)</strong>;//销毁树 T。
<strong>CreateTree(&#x26;T,definition)</strong>;//构造树 T
<strong>ClearTree(&#x26;T)</strong>; //将树 T 清为空树。
<strong>TreeEmpty(T)</strong>; //若 T 为空树，则返回 TRUE;
<strong>TreeDepth(T)</strong>; //返回Ｔ的深度。
<strong>Root(T);</strong>//返回 T 的根。</p>
<h3 id="基本操作-4"><a href="#基本操作-4">基本操作</a></h3>
<p><strong>Value(T,cur_e)</strong>;//返回 cur_e 的值。<br>
<strong>Assign(T,cur_e,value)</strong>; //结点 cur_e 赋值为 value。
<strong>Parent(T,cur_e)</strong>; //若 cur_e 是 T 的非根结点，则返回它的双亲;
<strong>LeftChild(T,cur_e)</strong>; //返回最左孩子;
<strong>RightSibling(T,cur_e);</strong> //返回它的右兄弟;
<strong>InsertChild(&#x26;T,&#x26;p,i,c)</strong>; //插入 c 为Ｔ中ｐ指结点的第ｉ棵子树。
<strong>DeleteChild(&#x26;T,&#x26;p,i)</strong>; //删除Ｔ中ｐ所指结点的第ｉ棵子树。
<strong>TraverseTree(T)</strong> //按某种次序对 T 的每个结点遍历</p>
<h3 id="双亲表示法-结构体"><a href="#双亲表示法-结构体">双亲表示法-结构体</a></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#6A737D"> //节点结构</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">    TElemType data;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> parent;</span><span style="color:#6A737D"> //双亲位置域</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">PTNode</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#6A737D"> //树结构</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">    PTNode node</span><span style="color:#ffab70">[</span><span style="color:#E1E4E8">MAX_TREE_SIZE</span><span style="color:#ffab70">]</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> r, n;</span><span style="color:#6A737D"> //根的位置和节点个数</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">PTree</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h3 id="孩子表示法"><a href="#孩子表示法">孩子表示法</a></h3>
<p>每个结点有多个指针域
每个指针指向一棵子树的根结点
多重链表表示法</p>
<h3 id="结构体-7"><a href="#结构体-7">结构体</a></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> CTNode</span><span style="color:#6A737D">      //孩子结点链</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> child;</span></span>
<span class="line"><span style="color:#F97583">    struct</span><span style="color:#B392F0"> CTNode</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">next;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#E1E4E8"> </span><span style="color:#F97583">*</span><span style="color:#B392F0">ChildPtr</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> CTBox</span><span style="color:#6A737D">      //孩子结点链</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#F97583">   char</span><span style="color:#E1E4E8"> data;</span></span>
<span class="line"><span style="color:#E1E4E8">   ChildPtr firstchild;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">CTBox</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#6A737D">            //树状结构</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">    CTBox nodes</span><span style="color:#ffab70">[</span><span style="color:#E1E4E8">MAX_TREE_SIZE</span><span style="color:#ffab70">]</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> r, n;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#E1E4E8"> </span><span style="color:#B392F0">CTree</span><span style="color:#E1E4E8"> ;</span></span></code></pre>
<h3 id="孩子双亲表示法"><a href="#孩子双亲表示法">孩子双亲表示法</a></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> CTNode</span><span style="color:#6A737D">     //孩子结点链</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> child;</span></span>
<span class="line"><span style="color:#F97583">    struct</span><span style="color:#B392F0"> CTNode</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">next;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#E1E4E8"> </span><span style="color:#F97583">*</span><span style="color:#B392F0">ChildPtr</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> CTBox</span><span style="color:#6A737D">      //孩子结点链</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#F97583">    char</span><span style="color:#E1E4E8"> data;</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8">  parent;</span></span>
<span class="line"><span style="color:#E1E4E8">    ChildPtr firstchild;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">CTBox</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#6A737D">            //树状结构</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">    CTBox nodes</span><span style="color:#ffab70">[</span><span style="color:#E1E4E8">MAX_TREE_SIZE</span><span style="color:#ffab70">]</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> r, n;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#E1E4E8"> </span><span style="color:#B392F0">CTree</span><span style="color:#E1E4E8"> ;</span></span></code></pre>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法">孩子兄弟表示法</a></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> Node</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">    DataType element;</span></span>
<span class="line"><span style="color:#F97583">    struct</span><span style="color:#B392F0"> Node</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8"> pFirstChild;</span></span>
<span class="line"><span style="color:#F97583">    struct</span><span style="color:#B392F0"> Node</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8"> pNextSibling;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#F97583">*</span><span style="color:#B392F0">Tree</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h3 id="二叉树"><a href="#二叉树">二叉树</a></h3>
<p>二叉树（Binary Tree）是 n 个结点的有限集合，该集合或者为空集，或者由一个根结点和两个互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p>
<h3 id="特征-2"><a href="#特征-2">特征</a></h3>
<ol>
<li>每个结点最多有两棵子树</li>
<li>左子树和右子树是有顺序的</li>
<li>即使某结点只有一棵子树，也要区分它是左子树还是右子树</li>
</ol>
<h3 id="形态"><a href="#形态">形态</a></h3>
<ul>
<li>空二叉树</li>
<li>只有一个根结点</li>
<li>根结点只有左子树</li>
<li>根结点只有右子树</li>
<li>根结点既有左子树又有右子树</li>
</ul>
<h3 id="特殊二叉树"><a href="#特殊二叉树">特殊二叉树</a></h3>
<p><strong>斜树：</strong>
所有结点都只有左子树的二叉树称为左斜树；
所有结点都只有右子树的二叉树称为右斜树；</p>
<p><strong>满二叉树：</strong>
所有结点都存在左子树和右子树，并且所有叶子结点都在同一层上。
叶子结点只能位于最下层
非叶结点的度一定是 2
同样深度的二叉树中，满二叉树的结点最多</p>
<p><strong>完全二叉树：</strong>
对于一棵有 n 个结点的二叉树按程序标号，如果编号为 i 的结点与同样深度的满二叉树编号为 i 的结点在二叉树中的位置完全相同。
叶子结点只能出现于最下两层
最下层的叶子结点一定连续位置
导数第二层，若有叶子结点，一定都在右布连续位置
如果结点度为 1，则该结点只能有左孩子
同样结点数的二叉树，完全二叉树的深度最小</p>
<h3 id="性质"><a href="#性质">性质</a></h3>
<p>二叉树的第 <strong>i</strong> 层之多有 **2<sup>(i-1) </sup>**个结点；</p>
<p>深度为 <strong>k</strong> 的二叉树至多有 <strong>2<sup>k</sup>-1</strong> 个结点；</p>
<p>任何一棵二叉树 T，如果其终端结点的个数为 n0，度为 2 的结点数为 n2，则 n0=n2+1；</p>
<p>具有 <strong>n</strong> 个结点的完全二叉树深度为 <strong>int(log<sub>2</sub>n)+1</strong>；</p>
<p>如果对一棵有 n 个结点的完全二叉树的结点按层序编号，对任意一个结点 i，有：</p>
<ul>
<li>如果 i=1，则结点 i 是二叉树的根；</li>
<li>如果 i>1，则其双亲结点 int(i/2);</li>
<li>如果 2i>n，则结点 i 无左孩子；</li>
<li>如果 2i+1>n，则结点 i 无右孩子；</li>
</ul>
<h3 id="二叉树顺序存储-作业"><a href="#二叉树顺序存储-作业">二叉树顺序存储-作业</a></h3>
<p><strong>课后作业：</strong>
定义二叉树顺序存储结构
创建、清空二叉树
求二叉树的深度
求二叉树结点的个数
求任何一个结点的左孩子，右孩子结点
求任何一个结点的双亲结点</p>
<h3 id="二叉链表"><a href="#二叉链表">二叉链表</a></h3>
<p>二叉树每个结点最多有两个孩子，可以为二叉树结点设置 1 个数据域和 2 个指针域</p>
<h4 id="结构体-8"><a href="#结构体-8">结构体</a></h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> Node</span><span style="color:#79b8ff">{</span><span style="color:#E1E4E8">  </span></span>
<span class="line"><span style="color:#E1E4E8">    ElemType data;</span></span>
<span class="line"><span style="color:#F97583">    struct</span><span style="color:#B392F0"> Node</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">lchild;</span></span>
<span class="line"><span style="color:#F97583">    struct</span><span style="color:#B392F0"> Node</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">rchild;  </span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">BiTNode</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">*</span><span style="color:#B392F0">BiTree</span><span style="color:#E1E4E8">; </span></span></code></pre>
<h3 id="二叉树遍历"><a href="#二叉树遍历">二叉树遍历</a></h3>
<ol>
<li>
<p><strong>前序遍历</strong></p>
<p>先遍历根结点
依次前序遍历左子树和右子树</p>
</li>
<li>
<p><strong>中序遍历</strong></p>
<p>从根结点开始
中序遍历左子树
访问根结点
中序遍历右子树</p>
</li>
<li>
<p><strong>后序遍历</strong></p>
<p>从根结点开始
后序遍历左子树
后序遍历右子树
访问根结点</p>
</li>
<li>
<p><strong>层序遍历</strong></p>
</li>
</ol>
<h3 id="线索二叉树"><a href="#线索二叉树">线索二叉树</a></h3>
<p>Threaded Binary Tree</p>
<ul>
<li>空指针废物利用，分别指向当前结点的前驱结点和后继结点；</li>
<li>变废为宝的空指针称为线索；</li>
<li>加上线索的二叉树称为线索二叉树。</li>
</ul>
<h3 id="结构体-9"><a href="#结构体-9">结构体</a></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> char</span><span style="color:#E1E4E8"> ElemType;</span><span style="color:#6A737D"> //数据类型</span></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> enum</span><span style="color:#E1E4E8"> </span><span style="color:#79b8ff">{</span><span style="color:#79B8FF">Link</span><span style="color:#E1E4E8">,</span><span style="color:#79B8FF">Thread</span><span style="color:#79b8ff">}</span><span style="color:#E1E4E8"> PointerTag;</span></span>
<span class="line"><span style="color:#6A737D">//Link==0表示左、右孩子结点，Thread==1表示指向前驱或后继的线索</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> BiThrNode</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">      ElemType data;</span></span>
<span class="line"><span style="color:#F97583">      struct</span><span style="color:#B392F0"> BiThrNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> lchild,</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> rchild;</span></span>
<span class="line"><span style="color:#E1E4E8">      PointerTag ltag;</span></span>
<span class="line"><span style="color:#E1E4E8">      PointerTag rtag;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#E1E4E8"> </span><span style="color:#B392F0">BiThrNode</span><span style="color:#E1E4E8">,</span><span style="color:#F97583">*</span><span style="color:#B392F0">BiThrTree</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h2 id="森林树二叉树"><a href="#森林树二叉树">森林，树，二叉树！</a></h2>
<h3 id="树转换成二叉树"><a href="#树转换成二叉树">树转换成二叉树</a></h3>
<p><strong>STEP1. 加线：</strong></p>
<p>所有兄弟结点之间加一条线；</p>
<p><strong>STEP2. 去线：</strong></p>
<p>对于树中每个结点，只保留其与第一个孩子结点的连线，删除其与其它孩子结点之间的连线；</p>
<p><strong>STEP3. 层次调整：</strong></p>
<p>以树的根结点为轴心，讲整个树顺时针旋转一定角度，使之层次分明。</p>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="717" height="249" src="/_astro/commonTree2bt.BKxqehLu_1KW8Ca.webp" ></p>
<center style="font-size:12px">树转换为二叉树</center>
<h3 id="森林转二叉树"><a href="#森林转二叉树">森林转二叉树</a></h3>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="547" height="360" src="/_astro/forest2bt.Tg7Bl5C8_13BCSo.webp" ></p>
<ol>
<li>把每棵树转换为二叉树；</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵树叶子节点的右孩子；</li>
</ol>
<h3 id="二叉树转树"><a href="#二叉树转树">二叉树转树</a></h3>
<blockquote>
<p>加线，去线，层次调整</p>
</blockquote>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="782" height="373" src="/_astro/bt2commonTree.Bq706VIP_riC5m.webp" ></p>
<h3 id="二叉树转森林"><a href="#二叉树转森林">二叉树转森林</a></h3>
<p>从根结点开始，若右孩子存在，则删除连接右孩子的线；
将得到的一系列二叉树转换为树；</p>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="600" height="239" src="/_astro/bt2forest.0b9Af6lq_Z2oRBrr.webp" ></p>
<h3 id="树的遍历"><a href="#树的遍历">树的遍历</a></h3>
<p><strong>先根遍历：</strong>
首先访问树的根结点，然后依次先根遍历根的每棵子树；</p>
<p><strong>后根遍历：</strong>
依次后根遍历每棵子树，然后再访问根结点；</p>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码">哈夫曼编码</a></h2>
<blockquote>
<p><strong>前缀编码：</strong></p>
<p>即较短的编码不能是任何较长的编码的前缀，这样解析的时候才不会混淆</p>
</blockquote>
<p>把要编码的字符放在二叉树的叶子上，所有的左节点是 0，右节点是 1，从根浏览到叶子上，因为字符只能出现在树叶上，任何一个字符的路径都不会是另一字符路径的前缀路径，符合前缀原则编码就可以得到。</p>
<p>构造更优的二叉树，原则就是权重越大的叶子，距离根应该越近，而我们的终级目标是生成“最优”的二叉树，最优二叉树必须符合下面两个条件：</p>
<ol>
<li>所有上层节点都大于等于下层节点。</li>
<li>某节点，设其较大的子节点为ｍ，较小的子节点为ｎ，ｍ下的任一层的所有节点都应大于等于ｎ下的该层的所有节点。</li>
</ol>
<h3 id="构造哈夫曼树"><a href="#构造哈夫曼树">构造哈夫曼树</a></h3>
<ol>
<li>从各个节点中找出最小的两个节点，给它们建一个父节点，值为这两个节点之和。</li>
<li>从节点序列中去除这两个节点，加入它们的父节点到序列中。</li>
<li>重复上面两个步骤，直到节点序列中只剩下唯一一个节点。这时一棵最优二叉树就已经建成了，它的根就是剩下的这个节点。</li>
</ol>
<h3 id="结构体-10"><a href="#结构体-10">结构体</a></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#6A737D">// 哈夫曼树节点</span></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> HuffNode</span><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> weight;</span></span>
<span class="line"><span style="color:#F97583">    char</span><span style="color:#E1E4E8"> ch;</span></span>
<span class="line"><span style="color:#E1E4E8">    string code;</span></span>
<span class="line"><span style="color:#F97583">    struct</span><span style="color:#B392F0"> HuffNode</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">rchild;</span></span>
<span class="line"><span style="color:#F97583">    struct</span><span style="color:#B392F0"> HuffNode</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">lchild;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">HuffMan</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 哈夫曼队列</span></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> Node</span><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">    HuffMan </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">data;</span></span>
<span class="line"><span style="color:#F97583">    struct</span><span style="color:#B392F0"> Node</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">next;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">ListNode</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">    ListNode </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">front;</span></span>
<span class="line"><span style="color:#E1E4E8">    ListNode </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">rear;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">Queue</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h2 id="树-作业"><a href="#树-作业">树-作业</a></h2>
<p>二叉树的建立
二叉树的遍历
二叉树 ADT 基本操作
二叉树线索化
线索二叉树的遍历
哈夫曼编码</p>
<h2 id="图"><a href="#图">图</a></h2>
<p>是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E）。其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合</p>
<p><strong>各种类型：</strong></p>
<ul>
<li>无向图</li>
<li>有向图</li>
<li>简单图</li>
<li>无向完全图</li>
<li>有向完全图</li>
<li>稀疏图</li>
<li>稠密图</li>
<li>带权图</li>
</ul>
<h3 id="概念-1"><a href="#概念-1">概念</a></h3>
<p><strong>路径：</strong>
树中根结点到任何一个结点的路径</p>
<p><strong>环：</strong>
第一个顶点和最后一个顶点相同的路径</p>
<p><strong>简单路径：</strong>
顶点不重复出现的路径</p>
<p><strong>简单环：</strong>
除第一个和最后一个顶点外，其余顶点不重复出现的回路</p>
<p><strong>连通图：</strong></p>
<ul>
<li>无向图中，如果从顶点 u 到顶点 v 有路径，则称 u 和 v 是联通的</li>
<li>如果图中任意两个顶点 u 和 v 都是连通的，则称该图为连通图</li>
</ul>
<p><strong>连通分量：</strong></p>
<p>无向图的极大连通子图称为<strong>连通分量</strong>( Connected Component)</p>
<p><strong>强连通图：</strong>
有向图中，对于每一对顶点 u 和 v，都存在由 u 到 v 和由 v 到 u 的路径，则称该图为强连通图。</p>
<p><strong>强连通分量：</strong>
有向图中的极大强连通子图称为有向图的强连通分量。</p>
<p><strong>生成树：</strong></p>
<p>一个连通图的生成树是一个极小连通子图，它含有图中全部的 n 个顶点，但只有足以构成一棵树的 n-1 条边。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵">邻接矩阵</a></h3>
<p>图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（成为邻接矩阵）存储图中边的信息。</p>
<h4 id="结构体-11"><a href="#结构体-11">结构体</a></h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">        VertexType vexs</span><span style="color:#ffab70">[</span><span style="color:#E1E4E8">MAXVEX</span><span style="color:#ffab70">]</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">        EdgeType arc</span><span style="color:#ffab70">[</span><span style="color:#E1E4E8">MAXVEX</span><span style="color:#ffab70">]</span><span style="color:#ffab70">[</span><span style="color:#E1E4E8">MAXVEX</span><span style="color:#ffab70">]</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">        int</span><span style="color:#E1E4E8"> numVertexes,numEdges;</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">MGraph</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h3 id="邻接表"><a href="#邻接表">邻接表</a></h3>
<ul>
<li>图中顶点用一个一维数组存储；</li>
<li>图中每个顶点 v 的所有邻接点构成一个线性表。</li>
</ul>
<h4 id="结构体-12"><a href="#结构体-12">结构体</a></h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#B392F0"> EdgeNode</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> adjvex;</span><span style="color:#6A737D"> //邻接点</span></span>
<span class="line"><span style="color:#E1E4E8">	EdgeWeight weight;</span><span style="color:#6A737D"> //权值</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#B392F0"> EdgeNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> next;</span><span style="color:#6A737D"> //指向下一条边</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">EdgeNode</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#E1E4E8"> string VertexType;</span><span style="color:#6A737D"> //顶点类型</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">	VertexType data;</span></span>
<span class="line"><span style="color:#E1E4E8">	EdgeNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> pFirstEdge;</span><span style="color:#6A737D"> //指示第一条边</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">VertexNode</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#E1E4E8"> VertexNode AdjList</span><span style="color:#79b8ff">[</span><span style="color:#E1E4E8">MAXVEX</span><span style="color:#79b8ff">]</span><span style="color:#E1E4E8">;</span><span style="color:#6A737D">//邻接表</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span></span>
<span class="line"><span style="color:#79b8ff">{</span></span>
<span class="line"><span style="color:#E1E4E8">	AdjList adjList;</span><span style="color:#6A737D"> //邻接表</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> iVexNum;</span><span style="color:#6A737D"> //顶点个数</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> iEdgeNum;</span><span style="color:#6A737D"> //边数</span></span>
<span class="line"><span style="color:#79b8ff">}</span><span style="color:#B392F0">AdjListGraph</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h3 id="最小生成树"><a href="#最小生成树">最小生成树</a></h3>
<p>构造连通网的最小代价生成树成为最小生成树</p>
<p>使用不同的遍历图的方法，可以得到不同的生成树；从不同的顶点出发，也可能得到不同的生成树。
按照生成树的定义，n 个顶点的连通网络的生成树有 n 个顶点、n-1 条边。</p>
<p><strong>构造最小生成树的准则：</strong></p>
<ol>
<li>用且仅用 n-1 条边来联结 n 个顶点；</li>
<li>不能使用产生回路的边；</li>
<li>各边上的权值的总和达到最小。</li>
</ol>
<h4 id="克鲁斯卡尔-kruskal-算法"><a href="#克鲁斯卡尔-kruskal-算法">克鲁斯卡尔 (Kruskal) 算法</a></h4>
<p><strong>基本思想：</strong>
设有一个有 n 个顶点的连通网络 N={V,E}, 最初先构造一个只有 n 个顶点,没有边的非连通图 T={V,<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math></span>}, 图中每个顶点自成一个连通分量。当在 E 中选到一条具有最小权值的边时, 若该边的两个顶点落在不同的连通分量上，则将此边加入到 T 中; 否则将此边舍去，重新选择一条权值最小的边。如此重复下去, 直到所有顶点在同一个连通分量上为止。</p>
<h4 id="普里姆prim算法"><a href="#普里姆prim算法">普里姆(Prim)算法</a></h4>
<p><strong>基本思想：</strong></p>
<ol>
<li>从连通网络 N={V,E}中的某一顶点 u0 出发,选择与它关联的具有最小权值的边 (u0,v),将其顶点加入到生成树顶点集合 U 中。</li>
<li>以后每一步从一个顶点在 U 中,而另一个顶点不在 U 中的各条边中选择权值最小的边(u,v),把顶点 v 加入到集合 U 中。如此继续下去,直到网络中的所有顶点都加入到生成树顶点集合 U 中为止。</li>
</ol>
<h3 id="最短路径"><a href="#最短路径">最短路径</a></h3>
<p>对于网图来说，最短路径是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</p>
<h4 id="单源最短路径"><a href="#单源最短路径">单源最短路径</a></h4>
<p>给定一个带权有向图 G=(V,E)，其中每条边的权是一个非负实数。另外，还给定 V 中的一个顶点，称为源。现在我们要计算从源到所有其他各顶点的最短路径长度。这里的长度是指路上各边权之和。这个问题通常称为单源最短路径问题。</p>
<h4 id="dijkstra-算法"><a href="#dijkstra-算法">Dijkstra 算法</a></h4>
<ol>
<li>按路径长度的递增次序,逐步产生顶点 v 到其它各顶点的最短路径。</li>
<li>即首先求出长度最短的一条最短路径，再参照它求出长度次短的一条最短路径，依次类推，直到从顶点 v 到其它各顶点的最短路径全部求出为止。</li>
</ol>
<h3 id="图-作业"><a href="#图-作业">图-作业</a></h3>
<p><strong>图的存储结构：</strong></p>
<ul>
<li>邻接矩阵</li>
<li>邻接表</li>
</ul>
<p><strong>图的遍历：</strong></p>
<ul>
<li>深度优先遍历</li>
<li>广度优先历</li>
</ul>
<p><strong>图的算法：</strong></p>
<ul>
<li>最小生成树（Prim，Kruskal）</li>
<li>单源最短路径</li>
</ul>
<h3 id="图-自学内容"><a href="#图-自学内容">图-自学内容</a></h3>
<p><strong>存储结构：</strong></p>
<ul>
<li>十字链表</li>
<li>邻接多重表</li>
</ul>
<p><strong>单源最短路径：</strong></p>
<ul>
<li>Floyd 算法</li>
</ul>
<p><strong>拓扑排序</strong></p>
<p><strong>关键路径</strong></p>
<!-- 还没更新的 内容 -->
<!--
队列

循环队列

对空堆满的条件

算法复杂度（排序算法）
计算方法，为什么要算

栈

树，
重点：二叉树

比如给后续遍历，写中序遍历

各种遍历结果


平衡二叉树


二叉树编程

算法设计，创建二叉树


数据结构的概念、

数据结构，算法，程序之间的关系


dj斯特拉算法复杂度，优缺点，

写最小生成树

某一种排序的第一次划分结果

编程题：

二叉树一系列问题（遍历...之类的）
单链表（插入删除，创建）
栈，队列
图（遍历....）
最短路径
最小生成树，


原理题目:

哈夫曼编码，哈夫曼树，排序（归并，快排，堆排序）

平衡二叉树看PPT，重点，课上讲的少
-->  </article> </div> <div class="max-sm:glassmorphism rounded-lg mt-2 sm:mt-6 p-2 pt-6"> <script type="module" src="/_astro/Giscus.astro_astro_type_script_index_0_lang.C2pfN53L.js"></script> <giscus-widget repo="miaobuao/miaobuao.github.io" repoId="R_kgDOJONNeg" categoryId="DIC_kwDOJONNes4CVJhu" mapping="og:title" strict="0" reactionsEnabled="1" emitMetadata="0" inputPosition="top" theme="preferred_color_scheme" lang="zh-CN" loading="lazy"></giscus-widget> </div> <div class="h-16 sm:h-0"></div>  </div> </main> </div> </div></div> </div><astro-island uid="gD63X" component-url="/_astro/WindowManager.DgB5G-u_.js" component-export="WindowManager" renderer-url="/_astro/client.DkS6DsO7.js" props="{&quot;class&quot;:[0,&quot;invisible md:visible not-md:pointer-events-none&quot;],&quot;data-astro-transition-persist&quot;:[0,&quot;wm&quot;]}" ssr client="only" opts="{&quot;name&quot;:&quot;WindowManager&quot;,&quot;value&quot;:&quot;solid-js&quot;}" data-astro-transition-persist="wm"></astro-island>  </body></html> <script defer>
	window.addEventListener(
		'wheel',
		(e) => {
			const scrollContainer = document.getElementById('main-scroll-container')
			if (e.target !== document.body) {
				return
			}
			e.preventDefault()
			scrollContainer.scrollTop += e.deltaY
		},
		{ passive: false },
	)
</script>